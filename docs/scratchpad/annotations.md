# Short-Lived Certificate Annotations in OpenPGP

In OpenPGP it is customary to make third-party certification signatures over User IDs to indicate the third-party keyholder's opinion about the UserID.
These third-party certifications are long-lived statements that form the basis of the Web of Trust.
It is often desirable to make short-lived statements independently of the WoT, and it would be convenient to attach these to a certificate using a transport- and implementation-neutral format.

## Issues with third-party certifications as short-lived annotations

Third-party certification signatures tend to cumulate when certificates are refreshed.
To prevent signature spam, it is increasingly common for implementations to limit the distribution of third-party signatures, through mechanisms such as 1pa3pc.
This would not always be a reasonable requirement for the distribution of short-lived annotations, particularly ones generated by automated processes such as freshness testing.

In addition, the creator of the annotation would be required to manage long-lived secret key material required to make the signatures.
This may be onerous if the annotation is generated by an automated process, and overkill if the annotations are short-lived.

## Issues with unhashed subpackets as short-lived annotations

Unhashed subpackets on existing signatures have been suggested as a vector for annotations, however these have their own issues.

Firstly, it is not always obvious which signature should have the annotations appended, or which signature(s) to examine to find annotations.
If the annotations do not pertain directly to a particular signature packet, but instead to its subject, new overriding signatures may be added at any time.
Implementations must then decide what to do with the annotations on older signatures:

* Does the lack of an annotation on a newer signature negate the presence of that annotation on an older signature?
* Should annotations be moved or copied onto the most recent signature?
* What should happen when older signatures are cleaned or minimised?

In addition, there are no standard methods for resolving conflicts between two signatures that are identical apart from the contents of their unhashed areas.
It is therefore difficult to predict how the time evolution of unhashed subpacket areas will be interpreted by the receiving implementation.

## Data we might wish to annotate:

* Foreign proofs, e.g. DKIM signatures
* Authentication signatures (submission only)
* Provenance logs
* Freshness tests
* Non-certificate user preferences (e.g. expect-signed)

## Other prior art

* vCards
* Email and HTTP headers
    * Transport-specific, but could be defined compatibly
* Form data fields
    * Submission only

## Ideas

* Novel non-critical packet to contain annotations.
* Human-readable annotations could be formatted as email or HTTP headers, for compatibility.
* Binary annotations could be stored in raw format to save base64 encoding costs.
* Could instead be implemented as unhashed notation subpackets, which support both human readable and binary formats.


# GnuPG Trust Packet

We reverse-engineer the GnuPG Trust Packet wire format.

octets | name            | type    | description
-------|-----------------|---------|--------------------------------------------
1      | trustval / flag | uint8   | key/uid/uat trust value OR "sig flag" (?)
1      | sigcache        | uint8   | signature flags (ignored unless SIG)
4      | (domsep)        |         | (optional)
├ 3    |   (unnamed)     | char[3] | "gpg" in UTF-8
└ 1    |   subtype       | uint8   | 0=SIG, 1=KEY, 2=UID
6+N    | (keydata)       |         | (optional, ignored if subtype is SIG)
├ 1    |   keyorg / src  | uint8   | key origin (see below)
├ 4    |   keyupdate     | uint32  | time of last update
├ 1    |   namelen       | uint8   | length of following field
└ N    |   updateurl     | char[N] | where to update key from?

The sigcache field is an octet of flag bits:
    bit 7: MUST be 0 (otherwise sigcache field is ignored)
    ...
    bit 1: valid (ignored if bit 0 is unset)
    bit 0: checked

All other bits are undefined.

The subtype field MUST correspond to the preceding packet:
    0 (SIG): preceding packet is a signature
    1 (KEY): preceding packet is a component key (public or secret)
    2 (UID): preceding packet is a User ID or User Attribute

The trust packet is ignored if the preceding packet type does not match the subtype, or if the generating application is not "gpg".

The sigcache field is ignored if the trustval/flag field is nonzero, even if the subtype is SIG.

If any of the subfields of the domsep or keydata groups are omitted, the entire group is ignored.

The key origin is one of the following values:

    KEYORG_UNKNOWN = 0,    
    KEYORG_KS      = 1, /* Public keyserver.    */    
    KEYORG_KS_PREF = 2, /* Preferred keysrver.  */    
    KEYORG_DANE    = 3, /* OpenPGP DANE.        */    
    KEYORG_WKD     = 4, /* Web Key Directory.   */    
    KEYORG_URL     = 5, /* Trusted URL.         */    
    KEYORG_FILE    = 6, /* Trusted file.        */    
    KEYORG_SELF    = 7  /* We generated it.     */


# OpenPGP Trust Packet

We define a generic construction for OpenPGP Trust Packets that is backwards compatible with the GnuPG Trust Packet:

octets | name            | type    | description
-------|-----------------|---------|--------------------------------------------
1      | trustval / flag | uint8   | key/uid/uat trust value OR "sig flag" (?)
1      | sigcache        | uint8   | signature flags
4      | domsep          | any     | domain separation
N      | further data    | any     | application-specific data (optional)

The basic form of the Trust Packet is two octets long, and consists of only the `trustval` and `sigcache` octets, which MUST be present.
The most-significant bit of the `sigcache` octet MUST be set, to prevent processing by legacy clients ((TODO: is this necessary?)).
In the OpenPGP packet format, these SHOULD be followed by four octets of domain separator, the first three of which SHOULD be constant for any given application.
The fourth octet of the domain separator MAY be used to differentiate between different modes of operation of the same application; it is RECOMMENDED to use the same semantics as GnuPG above.
An arbitrary number of further octets MAY be appended; the contents are application-dependent.


# HKP Trust Packet

HKP trust packets MUST start with the six octets:
    
    [ value, flags, 'h', 'k', 'p', subtype ]

The first octet holds the confidence value that the server attributes to the User ID.
The second octet contains flags:
    bit 7: MUST be 1
    bit 6: authoritative response
    ...
    bit 1: valid (ignored if bit 0 is unset)
    bit 0: checked

All other bits are undefined.

The next four octets contain the string "hkp" in UTF-8, followed by the subtype octet, which admits the same values as GnuPG.
The trust packet MUST be ignored if the subtype octet does not correspond to the type of the preceding packet.

The remainder of the trust packet consists of zero or more signature subpackets.
These MAY include:

* embedded signature
* preferred keyserver
* notation data

An embedded signature subpacket MAY be used to store signature packets that the local implementation wishes to associate with the preceding packet.
This is often more convenient than storing an embedded signature in the unhashed area of another signature, particularly if certificate merging and/or minimisation is implemented.

Supported notations include:

* keyorigin (string): (see below)
* keyupdate (uint32): OpenPGP timestamp
* proof (data): (format TBC)

The notation names will be allocated in the user namespace (exact format TBC).

Supported keyorigin values include:

value       | description
------------|------------------------------------------------
submitted   | directly submitted from a client
dump        | loaded from a dump that did not record an origin, or which was not sufficiently trusted
dns         | obtained from DNS lookup (DANE)
well-known  | fetched from a domain-authoritative web service such as WKD or HKP discovery
preferred   | fetched from the owner's self-declared preferred keyserver

Other keyorigin values are not currently used.


## Use of the HKP Trust Packet for User ID verification

One or more HKP Trust packets MAY be included when submitting or retrieving a certificate over HKPv2.
The HKP Trust packet immediately follows the User ID packet to which it applies, before any certification signatures.
A Trust packet in this position MUST have subtype 2 (UID).

When submitting a User ID:
    value MUST be 0
    flags MUST be 128
    domsep MUST be 'hkp\x02'
    proof notation SHOULD include an offline proof of User ID ownership (e.g. DKIM signed mail) [HIP-8]

Note that submitting a Trust packet with no proof notation is not useful.

When storing (and subsequently serving) a User ID:
    value SHOULD be zero unless the keyserver has performed verification
    flags SHOULD be set according to the verification results
    domsep MUST be 'hkp\x02'
    keyorigin notation SHOULD be set to indicate the source of the certificate
    keyupdate notation SHOULD be the date of submission
    preferred keyserver (if given) SHOULD be the authoritative location of the certificate
    proof notation MAY include any offline proof(s) known to the keyserver

On receiving a User ID with a suffixed Trust packet over HKP, the receiving application SHOULD NOT blindly import the Trust packet.
Trust packets record subjective information - the receiving application SHOULD evaluate that information and reconstruct the Trust packet to reflect its own calculations, otherwise it SHOULD discard the Trust packet.
In particular, the value and flags fields and keyorigin notation SHOULD be recalculated.

Care SHOULD be taken to validate or strip incoming trust packets, to prevent poisoning attacks.


### SKS considerations

HKP trust packets MUST be excluded from any digest calculation over a certificate for SKS purposes.
A keyserver MAY apply different weight to evidence obtained over different channels.
In particular, a Trust packet synced from a known SKS peer MAY be given more credence than one submitted or obtained over HKP.

For the purposes of [HIP-3], when reconciling two User IDs that have the same most-recent self-certification but disjoint third-party certifications, the copy with the earlier date field in the trust packet SHOULD take precedence.


## Use of the Trust Packet to Cache User ID Data

(NOTE: this will be implemented in a separate SKS trust packet, see https://github.com/hockeypuck/hockeypuck/wiki/HIP-013%3A-In%E2%80%90Band-Metadata-Sync-Using-Trust-Packets/)

We MAY wish to cache User ID data outside the User ID packet, for example if we wanted to serve hard revocations for enumerable domains we could store the domain portion in a Trust packet following the primary key after the corresponding userid has been redacted. [#317]
This MAY be synced between servers that share an enumerable domain configuration, but SHOULD be removed before serving to clients.

A Trust packet in this position MUST have subtype 1 (KEY).

# References

* https://gitlab.com/freepg/gnupg/-/blob/master/g10/parse-packet.c#L3423
* https://gitlab.com/freepg/gnupg/-/blob/master/g10/packet.h#L529
* https://gitlab.com/freepg/gnupg/-/blob/master/g10/keydb.h#L144
